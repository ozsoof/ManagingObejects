<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
        html, body {
            /* margin: 0; */
            height: 100%;
            background-color: #f0f0f0;
            color: #444;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: absolute;
            left: 1em;
            top: 1em;
            background: rgba(0,0,0,.8);
            padding: .5em;
            color: white;
            font-family: monospace;
        }
    </style>
    <title>3js test page</title>
  </head>
  <body>
    <canvas id="c"></canvas>    
    <div id="info">
        <strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel
    </div>
    <script type="module">
        
		import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
        import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';

        let camera, scene, renderer;
        let plane;
        let mouse, raycaster, isShiftDown = false;

        let rollOverMesh, rollOverMaterial;
        let cubeGeo, cubeMaterial;

        const canvas = document.querySelector('#c')
        const objects = [];

        init();
        render();

        function init() {

            camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( 500, 800, 1300 );
            camera.lookAt( 0, 0, 0 );

                      
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xf0f0f0 );

            // roll-over helpers

            const rollOverGeo = new THREE.BoxBufferGeometry( 20, 20, 20 );
            rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.4, transparent: true } );
            rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
            scene.add( rollOverMesh );

            // cubes

            cubeGeo = new THREE.BoxBufferGeometry( 20, 20, 20 );
            cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c});

            // grid

            const gridHelper = new THREE.GridHelper( 1000, 50 );
            scene.add( gridHelper );

            //

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            const geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
            geometry.rotateX( - Math.PI / 2 );

            plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false} ) );
            scene.add( plane );


            // const plane2 = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: true } ) );
            // plane2.position.y = 40; 
            // scene.add( plane2 );

            objects.push( plane );

            // lights

            const ambientLight = new THREE.AmbientLight( 0x606060 );
            scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff );
            directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
            scene.add( directionalLight );

            renderer = new THREE.WebGLRenderer( {canvas: canvas, antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );

            document.addEventListener( 'mousemove', onDocumentMouseMove, false );
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );
            document.addEventListener( 'keydown', onDocumentKeyDown, false );
            document.addEventListener( 'keyup', onDocumentKeyUp, false );

            window.addEventListener( 'resize', onWindowResize, false );

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        function onDocumentMouseMove( event ) {

            event.preventDefault();

            mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

            raycaster.setFromCamera( mouse, camera );

            const intersects = raycaster.intersectObjects( objects );

            if ( intersects.length > 0 ) {

                const intersect = intersects[ 0 ];

                rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
                rollOverMesh.position.divideScalar( 20 ).floor().multiplyScalar( 20 ).addScalar( 10 );

            }

            render();

        }

        function onDocumentMouseDown( event ) {

            event.preventDefault();

            mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

            raycaster.setFromCamera( mouse, camera );

            const intersects = raycaster.intersectObjects( objects );

            if ( intersects.length > 0 ) {

                const intersect = intersects[ 0 ];

                // delete cube

                if ( isShiftDown ) {

                    if ( intersect.object !== plane ) {

                        scene.remove( intersect.object );

                        objects.splice( objects.indexOf( intersect.object ), 1 );

                    }

                // create cube

                } else {

                    const voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
                    voxel.position.copy( intersect.point ).add( intersect.face.normal );
                    voxel.position.divideScalar( 20 ).floor().multiplyScalar( 20 ).addScalar( 10 );
                    scene.add( voxel );

                    objects.push( voxel );

                }

                render();

            }

        }

        function onDocumentKeyDown( event ) {

            switch ( event.keyCode ) {

                case 16: isShiftDown = true; break;

            }

        }

        function onDocumentKeyUp( event ) {

            switch ( event.keyCode ) {

                case 16: isShiftDown = false; break;

            }

        }

        function render() {

            renderer.render( scene, camera );
           // requestAnimationFrame(render);

        }
        //requestAnimationFrame(render);
    </script>
  </body>
</html>