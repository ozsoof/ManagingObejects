<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <style>
        html, body {
            /* margin: 0; */
            height: 100%;
        }
        #c {
            width: 100%;
            height: 100%;
            display: block;
        }
        #info {
            position: absolute;
            left: 1em;
            top: 1em;
            background: rgba(0,0,0,.8);
            padding: .5em;
            color: white;
            font-family: monospace;
        }
    </style>
    <title>3js test page</title>
  </head>
  <body>
    <canvas id="c"></canvas>    
    <div id="labels"></div>
    <script type="module">

        import * as THREE from './three.js/build/three.module.js';
        import { GUI } from './node_modules/dat.gui/build/dat.gui.module.js';;
        import { OrbitControls } from './three.js/examples/jsm/controls/OrbitControls.js';
        import { TransformControls } from './three.js/examples/jsm/controls/TransformControls.js';
        import {OBJLoader} from './three.js/examples/jsm/loaders/OBJLoader.js';

        function main() {

            const canvas =document.querySelector('#c'); 
            const renderer = new THREE.WebGLRenderer({canvas: canvas});
            // const gui = new GUI();
            renderer.setClearColor(0xAAAAAA);
            renderer.shadowMap.enabled = true;

            function makeCamera(fov = 75){
                const aspect =2;
                const zNear = 0.1;
                const zFar = 1000;
                
                return new THREE.PerspectiveCamera(fov, aspect, zNear, zFar);
            }

            const camera = makeCamera();
            
        
            camera.position.set(10, 40, 70)
            //camera.lookAt(0,0,0);
            {
                const light = new THREE.DirectionalLight(0xffffff,1);
                light.position.set(2,2,4);

                camera.add(light);
            }

            const controls = new OrbitControls(camera, canvas);
            controls.target.set(0,2,0);
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI / 2;
            controls.update();

            

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xAAAAAA);

            
            // const gridHelper = new THREE.GridHelper( 1000, 20 );
            // scene.add( gridHelper );

            // {
            //     const objLoader = new OBJLoader2();
            //     objLoader.load('./cctv/camera.obj', (root) => {
            //         scene.add(root);
            //     });
            // }

            { 
                const light = new THREE.DirectionalLight(0xffffff, 1);
            
                light.position.set(0,20,0); 
                scene.add(light);
                light.castShadow = false;
                light.shadow.mapSize.width = 2048;
                light.shadow.mapSize.height = 2048;

                const d = 50;
                light.shadow.camera.left = -d;
                light.shadow.camera.right = d;
                light.shadow.camera.top = d;
                light.shadow.camera.bottom = -d;
                light.shadow.camera.near = 1;
                light.shadow.camera.far = 50;
                light.shadow.bias = 0.001;
            }

            {
                const light = new THREE.DirectionalLight(0xffffff,1);
                light.position.set(10,40,70);
                scene.add(light);
            }

            const ground = new THREE.Object3D();
            const groundGeometry = new THREE.PlaneBufferGeometry(100,100);
            const groundMaterial = new THREE.MeshPhongMaterial({color: 0xFFFAF0});
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = Math.PI * -.5;
            groundMesh.receiveShadow = false;
            ground.add(groundMesh);
            scene.add(ground);            

            const floor1 = new THREE.Object3D();
            floor1.position.y = 0;
            scene.add(floor1);

            const block1_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);    // width .5 , height 4, length 50 
            const block2_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);
            const block3_Geometry = new THREE.BoxBufferGeometry(80, 10, 0.5);
            const block4_Geometry = new THREE.BoxBufferGeometry(80, 10, 0.5);
            //const floor2Geometry = new THREE.BoxBufferGeometry(80, 0.5, 50);

            const sideMaterial = new THREE.MeshPhongMaterial({color: 0xADD8E6});
            const block1_Mesh = new THREE.Mesh(block1_Geometry, sideMaterial);
            block1_Mesh.position.y = 5;
            block1_Mesh.position.x = 40;
            const block2_Mesh = new THREE.Mesh(block2_Geometry, sideMaterial);
            block2_Mesh.position.y = 5;
            block2_Mesh.position.x = -40;
            const block3_Mesh = new THREE.Mesh(block3_Geometry, sideMaterial);
            block3_Mesh.position.y = 5;
            block3_Mesh.position.z = 25;
            const block4_Mesh = new THREE.Mesh(block4_Geometry, sideMaterial);
            block4_Mesh.position.y = 5;
            block4_Mesh.position.z = -25;

            const centerGeometry = new THREE.BoxBufferGeometry(80, 0.5, 50);
            const centerMesh = new THREE.Mesh(centerGeometry, sideMaterial);
                    
            floor1.add(block1_Mesh);
            floor1.add(block2_Mesh);
            floor1.add(block3_Mesh);
            floor1.add(block4_Mesh);
            // floor1.add(centerMesh);
            scene.add(centerMesh);

            const floor2 = new THREE.Object3D();
            floor2.position.y = 20;
            scene.add(floor2);

            const f2block1_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 20);    // width .5 , height 4, length 50 
            const f2block2_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);
            const f2block3_Geometry = new THREE.BoxBufferGeometry(60, 10, 0.5);
            const f2block4_Geometry = new THREE.BoxBufferGeometry(80, 10, 0.5);
            
            const f2block5_Geometry = new THREE.BoxBufferGeometry(20, 10, 0.5);
            const f2block6_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 30);
            const f2block7_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);

            const floor2Geometry = new THREE.BoxBufferGeometry(80, 0.5, 50);

            


            const side2Material = new THREE.MeshPhongMaterial({color: 0xADD8E6});
            const f2block1_Mesh = new THREE.Mesh(f2block1_Geometry, side2Material);
            f2block1_Mesh.position.y = 5;
            f2block1_Mesh.position.x = 40;
            f2block1_Mesh.position.z = -15;
            const f2block2_Mesh = new THREE.Mesh(f2block2_Geometry, side2Material);
            f2block2_Mesh.position.y = 5;
            f2block2_Mesh.position.x = -40;
            const f2block3_Mesh = new THREE.Mesh(f2block3_Geometry, side2Material);
            f2block3_Mesh.position.y = 5;
            f2block3_Mesh.position.x = -10;
            f2block3_Mesh.position.z = 25;
            const f2block4_Mesh = new THREE.Mesh(f2block4_Geometry, side2Material);
            f2block4_Mesh.position.y = 5;
            f2block4_Mesh.position.z = -25;
            const f2block5_Mesh = new THREE.Mesh(f2block5_Geometry, side2Material);
            f2block5_Mesh.position.y = 5;
            f2block5_Mesh.position.x = 30;
            f2block5_Mesh.position.z = -5;
            const f2block6_Mesh = new THREE.Mesh(f2block6_Geometry, side2Material);
            f2block6_Mesh.position.y = 5;
            f2block6_Mesh.position.x = 20;
            f2block6_Mesh.position.z = 10;
            const f2block7_Mesh = new THREE.Mesh(f2block7_Geometry, side2Material);
            f2block7_Mesh.position.y = 5;
            f2block7_Mesh.position.x = 39.5;
            f2block7_Mesh.position.z = 24.5;



            const floor2Mesh = new THREE.Mesh(floor2Geometry, side2Material);
            

            floor2.add(f2block1_Mesh);
            floor2.add(f2block2_Mesh);
            floor2.add(f2block3_Mesh);
            floor2.add(f2block4_Mesh);

            floor2.add(f2block5_Mesh);
            floor2.add(f2block6_Mesh);
            floor2.add(f2block7_Mesh);


            floor2.add(floor2Mesh);
            floor2Mesh.position.y = 20;
            scene.add(floor2Mesh);


            const floor3 = new THREE.Object3D();
            floor3.position.y = 40;
            scene.add(floor3);
            
            const f3block1_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);    // width .5 , height 4, length 50 
            const f3block2_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);
            const f3block3_Geometry = new THREE.BoxBufferGeometry(60, 10, 0.5);
            const f3block4_Geometry = new THREE.BoxBufferGeometry(60, 10, 0.5);
            
            const f3block5_Geometry = new THREE.BoxBufferGeometry(20, 10, 0.5);
            // const f3block6_Geometry = new THREE.BoxBufferGeometry(0.5, 10, 50);
            const f3block7_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);
            const f3block8_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);
            const f3block9_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);
            const f3block10_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);
            const f3block11_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);
            const f3block12_Geometry = new THREE.BoxBufferGeometry(1, 10, 1);

            const floor3Geometry = new THREE.BoxBufferGeometry(80, 0.5, 50);


            const side3Material = new THREE.MeshPhongMaterial({color: 0xADD8E6});
            const f3block1_Mesh = new THREE.Mesh(f3block1_Geometry, side3Material);
            f3block1_Mesh.position.y = 5;
            f3block1_Mesh.position.x = 20;
            //f3block1_Mesh.position.z = 40;
            const f3block2_Mesh = new THREE.Mesh(f3block2_Geometry, side3Material);
            f3block2_Mesh.position.y = 5;
            f3block2_Mesh.position.x = -40;
            // f3block2_Mesh.position.z = 15;
            const f3block3_Mesh = new THREE.Mesh(f3block3_Geometry, side3Material);
            f3block3_Mesh.position.y = 5;
            f3block3_Mesh.position.x = -10;
            f3block3_Mesh.position.z = 25;
            const f3block4_Mesh = new THREE.Mesh(f3block4_Geometry, side3Material);
            f3block4_Mesh.position.y = 5;
            f3block4_Mesh.position.x = -10;
            f3block4_Mesh.position.z = -25;
            // const f3block5_Mesh = new THREE.Mesh(f3block5_Geometry, side3Material);
            // f3block5_Mesh.position.y = 5;
            // f3block5_Mesh.position.x = 30;
            // f3block5_Mesh.position.z = -5;
            // const f3block6_Mesh = new THREE.Mesh(f3block6_Geometry, side3Material);
            // f3block6_Mesh.position.y = 5;
            // f3block6_Mesh.position.x = 20;
            // f3block6_Mesh.position.z = 10;
            const f3block7_Mesh = new THREE.Mesh(f3block7_Geometry, side3Material);
            f3block7_Mesh.position.y = 5;
            f3block7_Mesh.position.x = 39.5;
            f3block7_Mesh.position.z = 24.5;
            const f3block8_Mesh = new THREE.Mesh(f3block8_Geometry, side3Material);
            f3block8_Mesh.position.y = 5;
            f3block8_Mesh.position.x = 39.5;
            f3block8_Mesh.position.z = 14.5;
            const f3block9_Mesh = new THREE.Mesh(f3block9_Geometry, side3Material);
            f3block9_Mesh.position.y = 5;
            f3block9_Mesh.position.x = 39.5;
            f3block9_Mesh.position.z = 4.5;
            const f3block10_Mesh = new THREE.Mesh(f3block10_Geometry, side3Material);
            f3block10_Mesh.position.y = 5;
            f3block10_Mesh.position.x = 39.5;
            f3block10_Mesh.position.z = -5.5;
            const f3block11_Mesh = new THREE.Mesh(f3block11_Geometry, side3Material);
            f3block11_Mesh.position.y = 5;
            f3block11_Mesh.position.x = 39.5;
            f3block11_Mesh.position.z = -15.5;
            const f3block12_Mesh = new THREE.Mesh(f3block12_Geometry, side3Material);
            f3block12_Mesh.position.y = 5;
            f3block12_Mesh.position.x = 39.5;
            f3block12_Mesh.position.z = -24.5;


            const floor3Mesh = new THREE.Mesh(floor3Geometry, side3Material);
            floor3Mesh.position.y= 40;

            floor3.add(f3block1_Mesh);
            floor3.add(f3block2_Mesh);
            floor3.add(f3block3_Mesh);
            floor3.add(f3block4_Mesh);

            //floor3.add(f3block5_Mesh);
            //floor3.add(f3block6_Mesh);
            floor3.add(f3block7_Mesh);
            floor3.add(f3block8_Mesh);
            floor3.add(f3block9_Mesh);
            floor3.add(f3block10_Mesh);
            floor3.add(f3block11_Mesh);
            floor3.add(f3block12_Mesh);
            
            floor3.add(floor3Mesh);

        
            scene.add(floor3Mesh);


            const floor4Geometry = new THREE.BoxBufferGeometry(80, 0.5, 50);
            const floor4Mesh = new THREE.Mesh(floor4Geometry, side3Material);
            scene.add(floor4Mesh);

            // const scene2 = new THREE.Scene();
            // const scene3 = new THREE.Scene();
            // const scene4 = new THREE.Scene();

            // scene2.add(floor1)
            // scene3.add(floor2)
            // scene4.add(floor3)


            function resizeRendererToDisplaySize(renderer) {
                const canvas = renderer.domElement;
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                const needResize = canvas.width !== width || canvas.height !== height;
                if (needResize) {
                    renderer.setSize(width, height, false);
                }

                return needResize;
            }

            class PickHelper {
                constructor() {
                    this.raycaster = new THREE.Raycaster();
                    this.pickedObject = null;
                    this.pickedObjectSavedColor =0;
                }

                pick(normalizedPosition, scene, camera, time){

                    if(this.pickedObject) {
                        this.pickedObject.material.emissive.setHex(this.pickedObjectSavedColor);
                        this.pickedObject = undefined;
                    }

                    this.raycaster.setFromCamera(normalizedPosition, camera);
                    const intersectedObjects = this.raycaster.intersectObjects(scene.children);
                    if (intersectedObjects.length) {
                        this.pickedObject = intersectedObjects[0].object;
                        this.pickedObjectSavedColor = this.pickedObject.material.emissive.getHex();
                        this.pickedObject.material.emissive.setHex((time * 0.8) % 2 > 1? 0xFFFF00 : 0xFF0000);

                    }
                }
            }

            const pickPosition = {x: 0, y: 0}
            const pickHelper = new PickHelper();
            const globals = {
                moveFloors : false,
                floor1: true,
                floor2: true,
                floor3: true,
                floor4: true,
            };
            
            
            const gui = new GUI();
            gui.add(globals, 'moveFloors').onChange(showHideDebugInfo);
            gui.add(globals, 'floor4').onChange(showHideDebugInfo);
            gui.add(globals, 'floor3').onChange(showHideDebugInfo);
            gui.add(globals, 'floor2').onChange(showHideDebugInfo);
            gui.add(globals, 'floor1').onChange(showHideDebugInfo);
        

            const labelContainerElem = document.querySelector('#labels');
            function showHideDebugInfo() {
            labelContainerElem.style.display = globals.moveFloors ? '' : 'none';
            labelContainerElem.style.display = globals.floor1 ? '' : 'none';
            labelContainerElem.style.display = globals.floor2 ? '' : 'none';
            labelContainerElem.style.display = globals.floor3 ? '' : 'none';
            labelContainerElem.style.display = globals.floor4 ? '' : 'none';

            }
            clearPickPosition();
        
        
            function render(time) {
                
                time *= 0.001; 
                //console.log(globals.moveFloors);
                if(resizeRendererToDisplaySize(renderer)){ 
                    const canvas = renderer.domElement;
                    camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    camera.updateProjectionMatrix();    
                }
            
                pickHelper.pick(pickPosition, scene, camera, time);

                if(globals.moveFloors && globals.floor1 && globals.floor2 && globals.floor3 && globals.floor4 ){ 
                    const y_position = ( time % 20 )
                    floor2.position.y = y_position > 10 ? -1 * (y_position -10) + 20 : y_position + 10;
                    floor2Mesh.position.y = y_position > 10 ? -1 * (y_position -10) + 20 : y_position + 10;
                    
                    floor3.position.y = y_position > 10 ? (y_position-10) + 30 : -1 * y_position + 40;
                    floor3Mesh.position.y = y_position > 10 ? (y_position-10) + 30 : -1 * y_position + 40;
                    floor4Mesh.position.y = y_position > 10 ? -1 * (y_position -10) + 60 : y_position + 50;

                    

                    scene.rotation.y = time* 0.02;
                }else{
                    floor1.position.y = 0;
                    floor2.position.y = 10;
                    floor2Mesh.position.y = 10;
                    floor3.position.y = 20;
                    floor3Mesh.position.y = 20;
                    floor4Mesh.position.y = 30;
                }

                if(!globals.floor1){
                    floor1.position.y = -100;
                    centerMesh.position.y = -10;
                }

                if(!globals.floor2){
                    floor2.position.y = -100;
                    floor2Mesh.position.y = -10;
                }

                if(!globals.floor3){
                    floor3.position.y = -100;
                    floor3Mesh.position.y = -10;
            
                }
                if(!globals.floor4){
            
                    floor4Mesh.position.y = -10;
                }

                renderer.render(scene, camera);

                requestAnimationFrame(render);

            }
            requestAnimationFrame(render);

            function getCanvasRelativePosition(event) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: (event.clientX - rect.left) * canvas.width /rect.width,
                    y: (event.clientY - rect.top) * canvas.height / rect.height,
                };
            }

            function setPickPosition(event) {
                const pos = getCanvasRelativePosition(event);
                pickPosition.x = (pos.x / canvas.width ) * 2 - 1;
                pickPosition.y = (pos.y /canvas.height) * -2 + 1;
            }

            function clearPickPosition() {
                pickPosition.x = -100000;
                pickPosition.y = -100000;
            }
            window.addEventListener('mousemove', setPickPosition);
            window.addEventListener('mouseoout', clearPickPosition);
            //window.addEventListener('', () => { moveFloor = false;} );
            // window.addEventListener('mousedown', });


        }

        main();

    </script>
  </body>
</html>